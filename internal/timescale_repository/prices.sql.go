// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: prices.sql

package timescale_repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSearchPriceChangesByName = `-- name: CountSearchPriceChangesByName :one
SELECT 
    COUNT(*) as count
FROM price_changes_24h
WHERE bucket = DATE_TRUNC('day', NOW() - INTERVAL '1 day')
    AND similarity(item_name, $1) > 0.3
`

func (q *Queries) CountSearchPriceChangesByName(ctx context.Context, query string) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchPriceChangesByName, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const get24HourPricesChanges = `-- name: Get24HourPricesChanges :many
WITH latest_sell_price AS (
    SELECT DISTINCT ON (item_id)
        item_id,
        sell_price as latest_sell_price
    FROM prices
    WHERE time >= NOW() - INTERVAL '2 hours'
    ORDER BY item_id, time DESC 
),
old_sell_price AS (
    SELECT DISTINCT ON (item_id)
        item_id,
        sell_price as old_sell_price
    FROM prices
    WHERE time BETWEEN NOW() - INTERVAL '26 hours' AND NOW() - INTERVAL '22 hours'
    ORDER BY item_id, time DESC
)
SELECT
    l.item_id,
    l.latest_sell_price,
    o.old_sell_price
FROM latest_sell_price l
JOIN old_sell_price o ON l.item_id = o.item_id
`

type Get24HourPricesChangesRow struct {
	ItemID          int32
	LatestSellPrice int32
	OldSellPrice    int32
}

func (q *Queries) Get24HourPricesChanges(ctx context.Context) ([]Get24HourPricesChangesRow, error) {
	rows, err := q.db.Query(ctx, get24HourPricesChanges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Get24HourPricesChangesRow
	for rows.Next() {
		var i Get24HourPricesChangesRow
		if err := rows.Scan(&i.ItemID, &i.LatestSellPrice, &i.OldSellPrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPriceChanges = `-- name: GetAllPriceChanges :many
SELECT 
        item_id::integer,
        item_name::text,
        bucket::timestamptz,
        open_price::integer,
        close_price::integer,
        sell_listings::integer,
        change_pct::float
FROM price_changes_24h
WHERE bucket = DATE_TRUNC('day', NOW() - INTERVAL '1 day')
ORDER BY 
    CASE WHEN $3::text = 'gainers' THEN change_pct END DESC,
    CASE WHEN $3::text = 'losers' THEN change_pct END ASC,
    change_pct DESC
LIMIT $1 OFFSET $2
`

type GetAllPriceChangesParams struct {
	Limit  int32
	Offset int32
	SortBy string
}

type GetAllPriceChangesRow struct {
	ItemID       int32
	ItemName     string
	Bucket       pgtype.Timestamptz
	OpenPrice    int32
	ClosePrice   int32
	SellListings int32
	ChangePct    float64
}

func (q *Queries) GetAllPriceChanges(ctx context.Context, arg GetAllPriceChangesParams) ([]GetAllPriceChangesRow, error) {
	rows, err := q.db.Query(ctx, getAllPriceChanges, arg.Limit, arg.Offset, arg.SortBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPriceChangesRow
	for rows.Next() {
		var i GetAllPriceChangesRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemName,
			&i.Bucket,
			&i.OpenPrice,
			&i.ClosePrice,
			&i.SellListings,
			&i.ChangePct,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemPriceChartByDay = `-- name: GetItemPriceChartByDay :many
SELECT 
    bucket::timestamptz,
    open_price::integer,
    close_price::integer,
    sell_listings::integer,
    change_pct::float
FROM price_changes_24h
WHERE item_id = $1
  AND bucket >= NOW() - $2::text::interval
ORDER BY bucket ASC
`

type GetItemPriceChartByDayParams struct {
	ItemID   int32
	Interval string
}

type GetItemPriceChartByDayRow struct {
	Bucket       pgtype.Timestamptz
	OpenPrice    int32
	ClosePrice   int32
	SellListings int32
	ChangePct    float64
}

func (q *Queries) GetItemPriceChartByDay(ctx context.Context, arg GetItemPriceChartByDayParams) ([]GetItemPriceChartByDayRow, error) {
	rows, err := q.db.Query(ctx, getItemPriceChartByDay, arg.ItemID, arg.Interval)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemPriceChartByDayRow
	for rows.Next() {
		var i GetItemPriceChartByDayRow
		if err := rows.Scan(
			&i.Bucket,
			&i.OpenPrice,
			&i.ClosePrice,
			&i.SellListings,
			&i.ChangePct,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemPriceChartByHour = `-- name: GetItemPriceChartByHour :many
SELECT 
    bucket::timestamptz,
    open_price::integer,
    close_price::integer,
    sell_listings::integer,
    change_pct::float
FROM price_changes_1h
WHERE item_id = $1
  AND bucket >= NOW() - $2::text::interval
ORDER BY bucket ASC
`

type GetItemPriceChartByHourParams struct {
	ItemID   int32
	Interval string
}

type GetItemPriceChartByHourRow struct {
	Bucket       pgtype.Timestamptz
	OpenPrice    int32
	ClosePrice   int32
	SellListings int32
	ChangePct    float64
}

func (q *Queries) GetItemPriceChartByHour(ctx context.Context, arg GetItemPriceChartByHourParams) ([]GetItemPriceChartByHourRow, error) {
	rows, err := q.db.Query(ctx, getItemPriceChartByHour, arg.ItemID, arg.Interval)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemPriceChartByHourRow
	for rows.Next() {
		var i GetItemPriceChartByHourRow
		if err := rows.Scan(
			&i.Bucket,
			&i.OpenPrice,
			&i.ClosePrice,
			&i.SellListings,
			&i.ChangePct,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemPriceStats = `-- name: GetItemPriceStats :one
SELECT
    MAX(CASE WHEN bucket >= NOW() - INTERVAL '7 days'   THEN close_price END)::integer AS high_7d,
    MIN(CASE WHEN bucket >= NOW() - INTERVAL '7 days'   THEN close_price END)::integer AS low_7d,
    MAX(CASE WHEN bucket >= NOW() - INTERVAL '1 month'  THEN close_price END)::integer AS high_1m,
    MIN(CASE WHEN bucket >= NOW() - INTERVAL '1 month'  THEN close_price END)::integer AS low_1m,
    MAX(CASE WHEN bucket >= NOW() - INTERVAL '3 months' THEN close_price END)::integer AS high_3m,
    MIN(CASE WHEN bucket >= NOW() - INTERVAL '3 months' THEN close_price END)::integer AS low_3m,
    MAX(CASE WHEN bucket >= NOW() - INTERVAL '6 months' THEN close_price END)::integer AS high_6m,
    MIN(CASE WHEN bucket >= NOW() - INTERVAL '6 months' THEN close_price END)::integer AS low_6m
FROM price_changes_24h
WHERE item_id = $1
  AND bucket >= NOW() - INTERVAL '6 months'
`

type GetItemPriceStatsRow struct {
	High7d int32
	Low7d  int32
	High1m int32
	Low1m  int32
	High3m int32
	Low3m  int32
	High6m int32
	Low6m  int32
}

func (q *Queries) GetItemPriceStats(ctx context.Context, itemID int32) (GetItemPriceStatsRow, error) {
	row := q.db.QueryRow(ctx, getItemPriceStats, itemID)
	var i GetItemPriceStatsRow
	err := row.Scan(
		&i.High7d,
		&i.Low7d,
		&i.High1m,
		&i.Low1m,
		&i.High3m,
		&i.Low3m,
		&i.High6m,
		&i.Low6m,
	)
	return i, err
}

const getItemSparklineWeekly = `-- name: GetItemSparklineWeekly :many
SELECT 
    item_id::integer,
    array_agg(close_price ORDER BY bucket ASC)::int[] AS sparkline
FROM price_changes_1h
WHERE item_id = ANY($1::int[])
  AND bucket >= NOW() - INTERVAL '7 days'
GROUP BY item_id
`

type GetItemSparklineWeeklyRow struct {
	ItemID    int32
	Sparkline []int32
}

func (q *Queries) GetItemSparklineWeekly(ctx context.Context, itemID []int32) ([]GetItemSparklineWeeklyRow, error) {
	rows, err := q.db.Query(ctx, getItemSparklineWeekly, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemSparklineWeeklyRow
	for rows.Next() {
		var i GetItemSparklineWeeklyRow
		if err := rows.Scan(&i.ItemID, &i.Sparkline); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPriceChangesByItemIDs = `-- name: GetPriceChangesByItemIDs :many
SELECT 
    item_id::integer,
      item_name::text,
    bucket::timestamptz,
    open_price::integer,
    close_price::integer,
    sell_listings::integer,
    change_pct::float
FROM price_changes_24h
WHERE bucket = DATE_TRUNC('day', NOW() - INTERVAL '1 day')
  AND item_id = ANY($1::int[])
LIMIT $2
`

type GetPriceChangesByItemIDsParams struct {
	ItemIds    []int32
	MaxResults int32
}

type GetPriceChangesByItemIDsRow struct {
	ItemID       int32
	ItemName     string
	Bucket       pgtype.Timestamptz
	OpenPrice    int32
	ClosePrice   int32
	SellListings int32
	ChangePct    float64
}

func (q *Queries) GetPriceChangesByItemIDs(ctx context.Context, arg GetPriceChangesByItemIDsParams) ([]GetPriceChangesByItemIDsRow, error) {
	rows, err := q.db.Query(ctx, getPriceChangesByItemIDs, arg.ItemIds, arg.MaxResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPriceChangesByItemIDsRow
	for rows.Next() {
		var i GetPriceChangesByItemIDsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemName,
			&i.Bucket,
			&i.OpenPrice,
			&i.ClosePrice,
			&i.SellListings,
			&i.ChangePct,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPrice = `-- name: InsertPrice :exec
INSERT INTO prices (
    item_id,
    sell_price,
    sell_listings,
    item_name
) VALUES ($1, $2, $3, $4)
`

type InsertPriceParams struct {
	ItemID       int32
	SellPrice    int32
	SellListings int32
	ItemName     pgtype.Text
}

func (q *Queries) InsertPrice(ctx context.Context, arg InsertPriceParams) error {
	_, err := q.db.Exec(ctx, insertPrice,
		arg.ItemID,
		arg.SellPrice,
		arg.SellListings,
		arg.ItemName,
	)
	return err
}

const searchPriceChangesByName = `-- name: SearchPriceChangesByName :many
SELECT 
    item_id::integer,
    item_name::text,
    bucket::timestamptz,
    open_price::integer,
    close_price::integer,
    sell_listings::integer,
    change_pct::float
FROM price_changes_24h
WHERE bucket = DATE_TRUNC('day', NOW() - INTERVAL '1 day')
    AND similarity(item_name, $3) > 0.3
ORDER BY 
    CASE WHEN $4::text = 'gainers' THEN change_pct END DESC,
    CASE WHEN $4::text = 'losers' THEN change_pct END ASC,
    CASE WHEN $4::text = 'relevance' OR $4::text = '' THEN similarity(item_name, $3) END DESC,
    change_pct DESC
LIMIT $1 OFFSET $2
`

type SearchPriceChangesByNameParams struct {
	Limit  int32
	Offset int32
	Query  string
	SortBy string
}

type SearchPriceChangesByNameRow struct {
	ItemID       int32
	ItemName     string
	Bucket       pgtype.Timestamptz
	OpenPrice    int32
	ClosePrice   int32
	SellListings int32
	ChangePct    float64
}

func (q *Queries) SearchPriceChangesByName(ctx context.Context, arg SearchPriceChangesByNameParams) ([]SearchPriceChangesByNameRow, error) {
	rows, err := q.db.Query(ctx, searchPriceChangesByName,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchPriceChangesByNameRow
	for rows.Next() {
		var i SearchPriceChangesByNameRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemName,
			&i.Bucket,
			&i.OpenPrice,
			&i.ClosePrice,
			&i.SellListings,
			&i.ChangePct,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
